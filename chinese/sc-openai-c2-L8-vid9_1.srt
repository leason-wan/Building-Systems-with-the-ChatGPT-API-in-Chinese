1
00:00:00,000 --> 00:00:06,300
在之前的几个视频中，

2
00:00:06,360 --> 00:00:10,260
Isa展示了如何使用llm构建应用程序

3
00:00:10,320 --> 00:00:14,460
从评估输入到处理输入

4
00:00:14,520 --> 00:00:18,560
再到在向用户显示输出之前进行最终输出检查。

5
00:00:19,260 --> 00:00:22,520
构建这样的系统后，如何知道它的工作情况？

6
00:00:22,600 --> 00:00:26,500
甚至在部署并让用户使用它时，

7
00:00:26,560 --> 00:00:29,020
如何跟踪它的运行情况

8
00:00:29,020 --> 00:00:32,280
并发现任何缺陷并继续改进

9
00:00:32,340 --> 00:00:34,720
系统的答案质量？

10
00:00:34,780 --> 00:00:37,520
在这个视频中，我想与您分享一些最佳实践

11
00:00:37,580 --> 00:00:41,040
用于评估llm的输出。

12
00:00:41,120 --> 00:00:42,920
我想特别与您分享

13
00:00:42,980 --> 00:00:46,140
构建这些系统的感受。

14
00:00:46,220 --> 00:00:50,080
您听到我在这个视频中谈论的一个关键区别

15
00:00:50,140 --> 00:00:53,480
和您可能在更传统的机器学习中看到的区别，

16
00:00:53,540 --> 00:00:56,440
监督学习应用程序之间的区别在于，因为您可以快速构建

17
00:00:56,440 --> 00:01:00,260
这样的应用程序，评估它的方法，

18
00:01:00,340 --> 00:01:03,100
它通常不会从测试集开始。

19
00:01:03,160 --> 00:01:08,540
相反，您经常会逐渐建立一组测试示例。

20
00:01:08,600 --> 00:01:10,640
让我与您分享我的意思。

21
00:01:10,700 --> 00:01:13,200
您将从第二个视频中记得这个图表

22
00:01:13,260 --> 00:01:17,000
关于如何基于提示开发加速核心部分

23
00:01:17,060 --> 00:01:22,140
的模型开发，从可能需要几个月到只需要几分钟或几小时
 
24
00:01:22,200 --> 00:01:24,300
或者最多只需要几天时间。

25
00:01:24,300 --> 00:01:27,100
在传统的监督学习方法中，

26
00:01:27,160 --> 00:01:31,260
如果你需要收集，比如说，10,000个标记样本，

27
00:01:31,340 --> 00:01:35,840
那么收集另外1000个测试样本的增量成本并不高。

28
00:01:35,900 --> 00:01:36,940
所以在传统的监督学习环境中，

29
00:01:37,000 --> 00:01:40,200
收集一个训练集，

30
00:01:40,260 --> 00:01:42,900
收集一个开发集或保留交叉验证集

31
00:01:42,960 --> 00:01:46,300
在测试集中，然后在整个开发过程中使用它们。

32
00:01:46,360 --> 00:01:48,740
但是如果你能够在几分钟内指定一个提示，

33
00:01:48,800 --> 00:01:51,260
并在几个小时内得到一些工作成果，

34
00:01:51,260 --> 00:01:54,620
那么如果你不得不暂停很长时间

35
00:01:54,680 --> 00:01:56,780
收集一千个测试样本，那将会是一个巨大的痛苦，

36
00:01:56,860 --> 00:01:58,660
因为现在你可以在零个训练样本的情况下得到这个工作成果。

37
00:01:58,720 --> 00:02:01,360
因此，在使用LLM构建应用程序时，

38
00:02:01,420 --> 00:02:03,680
这通常是它的感觉。

39
00:02:03,760 --> 00:02:07,480
首先，你会在只有一到三到五个样本的小样本中调整提示，

40
00:02:08,060 --> 00:02:11,360
并尝试让提示在它们身上起作用。

41
00:02:11,420 --> 00:02:13,420
然后，当系统进行额外的测试时，

42
00:02:13,480 --> 00:02:17,420
你偶尔会遇到一些棘手的例子。

43
00:02:17,480 --> 00:02:20,320
提示在它们身上不起作用，或者算法在它们身上不起作用。

44
00:02:20,320 --> 00:02:22,800
这就是使用chatgpt api的开发者如何构建应用程序的过程。
 
48
00:02:33,820 --> 00:02:36,800
在这种情况下，您可以将这些额外的一个或两个

49
00:02:36,860 --> 00:02:41,000
或三个或五个示例添加到您正在测试的集合中

50
00:02:41,060 --> 00:02:44,260
以机会主义地添加其他棘手的示例。

51
00:02:44,960 --> 00:02:48,320
最终，您已经添加了足够的这些示例

52
00:02:48,320 --> 00:02:51,840
到您缓慢增长的开发集中

53
00:02:51,920 --> 00:02:54,120
它变得有点不方便

54
00:02:54,180 --> 00:02:56,620
手动运行每个示例通过提示

55
00:02:56,680 --> 00:02:58,120
每次更改提示时。

56
00:02:58,180 --> 00:03:01,280
然后，您开始开发用于衡量性能的指标

57
00:03:01,340 --> 00:03:04,320
在这些小示例集上，例如平均准确性。

58
00:03:05,380 --> 00:03:09,440
这个过程的一个有趣方面

59
00:03:09,520 --> 00:03:12,480
是如果您随时决定

60
00:03:12,540 --> 00:03:14,380
您的系统已经足够好了，

61
00:03:14,440 --> 00:03:16,520
你可以停在那里不用它。

62
00:03:16,520 --> 00:03:19,860
您可以在那里停下，不继续下一个项目。

63
00:03:20,460 --> 00:03:22,620
事实上，有许多部署应用程序

64
00:03:22,680 --> 00:03:25,980
停在第一或第二个项目

65
00:03:26,060 --> 00:03:29,060
并且运行得非常好。

66
00:03:30,320 --> 00:03:35,180
现在，如果您手动构建的开发集

67
00:03:35,260 --> 00:03:37,120
您正在评估模型的性能

68
00:03:37,180 --> 00:03:39,520
还没有给您足够的信心

69
00:03:39,580 --> 00:03:41,160
在您的系统性能方面，

70
00:03:41,220 --> 00:03:43,720
那么这就是您可能要采取的下一步

71
00:03:43,720 --> 00:03:47,560
收集随机抽样的示例集

72
00:03:47,620 --> 00:03:49,320
来调整模型。
 
73
00:03:49,400 --> 00:03:52,360
这将继续作为开发集

74
00:03:52,420 --> 00:03:53,920
或保留交叉验证集，

75
00:03:54,000 --> 00:03:58,800
因为继续调整提示很常见。

76
00:03:59,760 --> 00:04:03,920
只有当您需要更高保真度的估计时，

77
00:04:04,000 --> 00:04:05,320
您的系统的性能，

78
00:04:05,400 --> 00:04:08,600
那么您可能会收集并使用保留测试集

79
00:04:08,660 --> 00:04:11,360
您自己不看

80
00:04:11,360 --> 00:04:14,200
当您调整模型时。

81
00:04:14,260 --> 00:04:17,660
因此，如果您的系统91％的时间得到正确答案，

82
00:04:17,740 --> 00:04:22,700
您想将其调整为92％的正确答案

83
00:04:22,760 --> 00:04:26,760
和你想要的93％，

84
00:04:26,840 --> 00:04:28,600
那么您确实需要更多的示例

85
00:04:28,660 --> 00:04:30,960
测量91％和93％性能之间的差异。

86
00:04:31,040 --> 00:04:36,500
然后只有当您真正需要一个无偏，

87
00:04:36,560 --> 00:04:40,000
公平的估计系统如何运行时，

88
00:04:40,000 --> 00:04:42,140
那么您需要超越开发集

89
00:04:42,200 --> 00:04:45,080
也收集保留测试集。

91
00:04:47,400 --> 00:04:49,100
一个重要的警告，

92
00:04:49,180 --> 00:04:51,780
我看到了许多大型语言模型的应用

93
00:04:51,840 --> 00:04:56,280
在其中没有实质性的风险

94
00:04:56,340 --> 00:04:58,780
如果它没有给出完全正确的答案。

95
00:04:58,840 --> 00:05:01,540
但是，对于任何高风险应用，

96
00:05:01,600 --> 00:05:05,940
如果存在偏见或不适当的输出的风险

97
00:05:06,000 --> 00:05:08,300
对某人造成伤害，

98
00:05:08,300 --> 00:05:10,720
那么收集测试集的责任
 
99
00:05:10,800 --> 00:05:13,420
严格评估系统的性能

100
00:05:13,500 --> 00:05:16,420
确保在使用之前它能够做正确的事情，

101
00:05:16,500 --> 00:05:18,660
这变得更加重要。

102
00:05:18,720 --> 00:05:20,520
但是，例如，

103
00:05:20,600 --> 00:05:23,160
如果你正在使用它来总结文章

104
00:05:23,220 --> 00:05:25,860
只是为了自己阅读而不是别人，

105
00:05:25,920 --> 00:05:28,600
那么可能造成的危害风险更小，

106
00:05:28,660 --> 00:05:30,720
你可以在这个过程中早早停止

107
00:05:30,800 --> 00:05:33,760
而不必去花费收集更大数据集的代价。

108
00:05:33,820 --> 00:05:37,920
因此，在这个例子中，

109
00:05:37,920 --> 00:05:40,880
让我从通常的辅助函数开始。

110
00:05:40,940 --> 00:05:43,680
使用一个工具函数来获取产品和类别列表。

111
00:05:48,240 --> 00:05:52,880
在计算机和笔记本电脑类别中，

112
00:05:52,940 --> 00:05:56,880
有一些计算机和笔记本电脑的清单。

113
00:05:56,940 --> 00:05:58,880
在智能手机和配件类别中，

114
00:05:58,940 --> 00:06:00,980
这是一些智能手机和配件的清单，

115
00:06:01,040 --> 00:06:03,080
以此类推其他类别。

116
00:06:03,080 --> 00:06:08,080
现在，假设一个地址的任务是给出用户输入，

117
00:06:11,780 --> 00:06:21,780
例如，如果我预算有限，我可以买什么电视

118
00:06:21,860 --> 00:06:25,980
以检索相关的类别和产品，

119
00:06:26,060 --> 00:06:30,060
以便我们有正确的信息来回答用户的查询。

120
00:06:30,060 --> 00:06:34,720
这样我们就可以回答用户的问题了。

121
00:06:34,800 --> 00:06:35,800
这是一个提示。

122
00:06:35,860 --> 00:06:36,920
如果你愿意，可以随时暂停视频

123
00:06:37,000 --> 00:06:39,200
并详细阅读这些内容。
 
124
00:06:39,260 --> 00:06:42,120
但提示指定了一组指令，

125
00:06:42,200 --> 00:06:44,700
实际上它给了语言模型

126
00:06:44,760 --> 00:06:47,000
一个好的输出示例。

127
00:06:47,060 --> 00:06:48,760
这有时被称为几次提示

128
00:06:48,820 --> 00:06:50,200
或技术上的一次提示

129
00:06:50,260 --> 00:06:52,560
因为我们实际上使用了用户消息

130
00:06:52,620 --> 00:06:56,500
和系统消息来给它一个好的输出示例。

131
00:06:56,560 --> 00:06:59,020
如果有人说，我想要最贵的电脑，

132
00:06:59,020 --> 00:07:01,180
让我们返回所有的电脑

133
00:07:01,240 --> 00:07:03,380
因为我们没有定价信息。

134
00:07:03,440 --> 00:07:08,120
现在，让我们在客户消息上使用这个提示，

135
00:07:08,180 --> 00:07:12,180
如果我预算有限，我可以买哪种电视？

136
00:07:15,040 --> 00:07:19,040
因此，我们将提示，

137
00:07:19,120 --> 00:07:22,040
客户消息零，以及产品和类别传递给它。

138
00:07:22,120 --> 00:07:24,540
这是我们在上面检索到的信息

139
00:07:24,620 --> 00:07:26,380
使用utils函数。

140
00:07:26,380 --> 00:07:30,320
这里列出了与此查询相关的相关信息，

141
00:07:30,380 --> 00:07:32,580
这是在电视类别下的

142
00:07:32,660 --> 00:07:33,720
和整个剧院系统。

143
00:07:33,780 --> 00:07:36,480
这是一个看起来相关的电视和整个剧院系统的列表

144
00:07:36,560 --> 00:07:37,760
。 

145
00:07:37,820 --> 00:07:39,520
要查看提示的效果如何，

146
00:07:39,580 --> 00:07:43,280
您可以在第二个提示上进行评估。

147
00:07:43,360 --> 00:07:46,960
客户说我需要一个智能手机充电器。

148
00:07:47,020 --> 00:07:52,060
看起来它正在正确地检索这些数据。

149
00:07:52,120 --> 00:07:53,620
类别是智能手机和配件，
 
150
00:07:53,680 --> 00:07:55,760
它列出了相关的产品

151
00:07:55,760 --> 00:07:57,760
这是另一个例子。

152
00:08:00,320 --> 00:08:02,560
那么你有哪些电脑？

153
00:08:02,620 --> 00:08:06,120
希望你能检索到电脑的列表。

154
00:08:06,200 --> 00:08:08,400
所以我有三个提示。

155
00:08:08,460 --> 00:08:12,560
如果你是第一次开发这个提示，

156
00:08:12,620 --> 00:08:16,360
有一个或两个或三个这样的例子是相当合理的，

157
00:08:16,420 --> 00:08:18,120
并且不断调整提示，

158
00:08:18,200 --> 00:08:19,860
直到它给出适当的输出，

159
00:08:19,920 --> 00:08:22,620
直到提示检索到相关的产品和类别

160
00:08:22,700 --> 00:08:25,200
对于你所有的提示，

161
00:08:25,200 --> 00:08:27,940
在这个例子中的所有三个提示。

162
00:08:28,000 --> 00:08:29,900
如果提示缺少一些产品或其他东西，

163
00:08:29,960 --> 00:08:31,600
那么我们可能会回去编辑提示几次，直到它做对了

164
00:08:34,360 --> 00:08:37,500
如果提示失败了，那么我们可能会回去编辑提示几次，直到它做对了

165
00:08:37,560 --> 00:08:39,760
在这里是一个提示的例子。

166
00:08:39,840 --> 00:08:41,960
告诉我关于SmartX配置文件和Philips Now相机的信息，

167
00:08:42,040 --> 00:08:43,640
在这三个提示中都是如此。

168
00:08:46,000 --> 00:08:49,600
在你把系统带到这个地步之后，

169
00:08:49,660 --> 00:08:52,900
你可能会开始在测试中运行系统，

170
00:08:52,900 --> 00:08:55,640
也许把它发送给内部测试用户

171
00:08:55,700 --> 00:08:57,240
或者尝试自己使用它

172
00:08:57,300 --> 00:09:00,140
并运行一段时间看看会发生什么。

173
00:09:00,200 --> 00:09:03,900
有时你会遇到一个提示

174
00:09:03,980 --> 00:09:05,540
它会失败。

175
00:09:05,600 --> 00:09:07,240
这是一个提示的例子。

176
00:09:07,300 --> 00:09:09,540
告诉我关于SmartX配置文件和Philips Now相机的信息，
 
177
00:09:09,600 --> 00:09:11,580
还有你有哪些电视。

178
00:09:11,640 --> 00:09:12,980
所以当我在这个提示符上运行它时，

179
00:09:13,040 --> 00:09:16,380
它看起来像是输出了正确的数据，

180
00:09:16,440 --> 00:09:18,640
但它也输出了一堆文本，

181
00:09:18,700 --> 00:09:20,440
这些是多余的。

182
00:09:20,440 --> 00:09:26,520
这使得将其解析为Python字典列表更加困难。

183
00:09:26,580 --> 00:09:29,720
所以我们不喜欢它输出这些多余的东西。

184
00:09:29,780 --> 00:09:34,580
所以当你遇到一个系统无法处理的例子时，

185
00:09:34,640 --> 00:09:36,980
常见的做法就是记录下来

186
00:09:37,040 --> 00:09:39,020
这是一个有点棘手的例子。

187
00:09:39,080 --> 00:09:41,280
所以让我们将其添加到我们要系统地测试的示例集中。

188
00:09:41,340 --> 00:09:44,580
如果你继续运行系统一段时间，

189
00:09:44,640 --> 00:09:47,980
也许它会在这些示例上工作。

190
00:09:48,040 --> 00:09:49,520
我们已经调整了提示符以适应三个示例，

191
00:09:51,260 --> 00:09:52,980
所以它可能会在许多示例上工作。

192
00:09:53,060 --> 00:09:56,760
但仅仅是偶然，你可能会遇到另一个例子

194
00:09:56,820 --> 00:09:58,660
它会生成一个错误。

195
00:09:58,720 --> 00:10:02,920
所以这个“also”客户消息会导致系统

196
00:10:02,980 --> 00:10:07,120
在末尾输出一堆我们不想要的垃圾文本。

197
00:10:10,320 --> 00:10:11,980
试图提供所有这些额外的文本，

198
00:10:12,060 --> 00:10:13,360
但我们实际上不想要这些。

199
00:10:13,420 --> 00:10:15,720
所以在这一点上，你可能已经运行了这个提示符

200
00:10:15,720 --> 00:10:19,500
也许是在数百个示例上，也许是在你的测试用户上，

201
00:10:19,560 --> 00:10:21,320
但你只需要拿这些示例，

202
00:10:21,400 --> 00:10:23,560
它表现不佳的棘手问题，

203
00:10:23,620 --> 00:10:28,360
现在有了这组从零到四索引的五个示例，

204
00:10:28,420 --> 00:10:30,560
有了这组你使用的五个示例

205
00:10:30,620 --> 00:10:32,460
进一步微调提示。

206
00:10:34,020 --> 00:10:38,220
在这两个示例中，

207
00:10:38,300 --> 00:10:41,800
LM输出了一堆我们不想要的额外垃圾文本

208
00:10:41,860 --> 00:10:44,020
在结尾处。

209
00:10:44,020 --> 00:10:46,640
经过一些试错，

210
00:10:46,720 --> 00:10:49,880
您可能会决定按以下方式修改提示。

211
00:10:51,020 --> 00:10:52,220
这是一个新提示。

212
00:10:52,280 --> 00:10:54,180
这称为提示V2。

213
00:10:54,240 --> 00:10:57,380
但我们在提示中添加了以下内容，

214
00:10:57,440 --> 00:11:00,180
不要输出任何不在JSON格式中的附加文本，

215
00:11:00,240 --> 00:11:03,080
强调一下，请不要输出这些JSON内容，

216
00:11:03,140 --> 00:11:06,840
并添加了第二个示例，使用用户和助手消息进行few-shot提示，

217
00:11:06,920 --> 00:11:09,180
其中用户询问最便宜的计算机。

218
00:11:09,240 --> 00:11:12,080
在这两个few-shot示例中，

219
00:11:12,080 --> 00:11:14,820
我们向系统演示了一个仅输出JSON的响应。

220
00:11:14,880 --> 00:11:17,760
因此，这是我们刚刚添加到提示中的额外内容，

221
00:11:17,820 --> 00:11:20,860
不要放置任何不在JSON格式中的附加文本。

222
00:11:20,920 --> 00:11:23,220
我们使用few-shot user one，few-shot assistant one，

223
00:11:23,280 --> 00:11:25,660
和few-shot user two，few-shot assistant two，

224
00:11:25,720 --> 00:11:29,060
为其提供了两个这些few-shot提示。
 
227
00:11:35,480 --> 00:11:38,960
所以让我按shift enter查找那个提示符。

228
00:11:39,020 --> 00:11:41,760
如果你回去手动重新运行这个提示符，

229
00:11:41,760 --> 00:11:44,000
在所有五个用户输入示例中重新运行它，

230
00:11:44,060 --> 00:11:47,360
包括之前输出错误的这个示例，

231
00:11:47,420 --> 00:11:50,100
你会发现它现在输出正确了。

232
00:11:51,100 --> 00:11:53,860
如果你回去重新运行这个新的提示符，

233
00:11:53,920 --> 00:11:59,120
这是提示符版本V2，在那个导致输出错误的客户消息示例上，

234
00:11:59,200 --> 00:12:01,120
它会生成更好的输出。

235
00:12:01,200 --> 00:12:03,400
有了JSON输出后面的额外垃圾，

236
00:12:03,960 --> 00:12:07,960
那么这将生成更好的输出。

237
00:12:08,700 --> 00:12:09,860
我不会在这里做这件事，

238
00:12:09,860 --> 00:12:12,040
但我鼓励你暂停视频，

239
00:12:12,100 --> 00:12:14,640
并在客户消息四上重新运行它自己

240
00:12:14,700 --> 00:12:16,600
以及这个提示符V2，

241
00:12:16,660 --> 00:12:20,000
看看它是否也生成了正确的输出。

242
00:12:20,060 --> 00:12:21,660
希望它会，我认为它应该会。

243
00:12:24,340 --> 00:12:26,640
当然，当你修改提示符时，

244
00:12:26,700 --> 00:12:31,140
做一些回归测试也是有用的，

245
00:12:31,200 --> 00:12:34,960
以确保在修复提示符三和四的不正确输出时，

246
00:12:35,040 --> 00:12:36,500
它不会破坏提示符零的输出。

247
00:12:36,500 --> 00:12:39,940
现在，你可以看出来，如果我必须复制粘贴五个提示符，

248
00:12:41,280 --> 00:12:46,080
例如零、一、二、三和四，

249
00:12:46,140 --> 00:12:49,040
到我的Jupyter Notebook中并运行它们，

250
00:12:49,100 --> 00:12:50,740
然后手动查看它们是否正在输出。
 
252
00:12:53,480 --> 00:12:56,380
通过正确的分类和产品，你可以做到这一点。

253
00:12:56,440 --> 00:12:58,540
我可以看到这个，然后说，是的，电视类别，

254
00:12:58,600 --> 00:13:00,040
和家庭影院系统产品。

255
00:13:00,100 --> 00:13:01,840
是的，看起来你都有了。

256
00:13:01,900 --> 00:13:04,380
但是手动完成这个过程有点痛苦，

257
00:13:04,380 --> 00:13:07,420
手动检查或查看这个输出，

258
00:13:07,480 --> 00:13:10,880
用你的眼睛确保这是完全正确的输出。

259
00:13:11,880 --> 00:13:15,920
因此，当你要调整的开发集不仅仅是一小部分示例时，

260
00:13:15,980 --> 00:13:18,820
开始自动化测试过程就变得有用了。

261
00:13:19,580 --> 00:13:25,520
这里有一组10个示例

263
00:13:31,780 --> 00:13:35,460
我在这里指定了10个客户留言。

264
00:13:35,520 --> 00:13:38,920
这是客户留言，我可以从预算中购买什么电视，

265
00:13:38,980 --> 00:13:41,520
以及什么是理想的答案。

266
00:13:41,580 --> 00:13:45,320
把它看作是测试集中的正确答案，

267
00:13:45,380 --> 00:13:46,980
或者真正应该说是开发集，

268
00:13:47,060 --> 00:13:48,920
因为我们实际上正在调整它。

269
00:13:48,980 --> 00:13:54,480
因此，我们在这里收集了10个示例，从零到九进行索引，

270
00:13:55,580 --> 00:13:58,620
最后一个是如果用户说，

271
00:13:58,620 --> 00:14:02,460
我想看热水浴缸时光机，我们没有相关产品，

272
00:14:02,520 --> 00:14:05,360
真的很抱歉。因此，理想的答案是空集。

273
00:14:06,720 --> 00:14:13,020
现在，如果你想自动评估，

274
00:14:13,400 --> 00:14:16,900
在这10个示例中，提示正在做什么，
 
275
00:14:17,500 --> 00:14:21,360
这里有一个函数可以实现这个功能。这是一个有点长的函数。

276
00:14:21,420 --> 00:14:23,800
如果你愿意，可以随时暂停视频并阅读它。

277
00:14:23,860 --> 00:14:26,800
但是让我演示一下它实际上在做什么。

278
00:14:26,800 --> 00:14:30,960
所以让我打印出客户信息零的客户信息。

279
00:14:31,940 --> 00:14:33,440
对，客户信息，

280
00:14:33,500 --> 00:14:35,600
如果我预算有限，我应该买哪种电视？

281
00:14:36,540 --> 00:14:40,860
让我们也打印出理想的答案。

282
00:14:40,940 --> 00:14:43,060
所以理想的答案是这里是所有的电视

283
00:14:43,140 --> 00:14:45,760
我们希望提示检索的。

284
00:14:48,000 --> 00:14:50,360
现在让我调用提示。

285
00:14:50,440 --> 00:14:53,600
这是这个客户信息上的提示 V2

286
00:14:53,660 --> 00:14:55,760
带有用户产品和类别信息。

287
00:14:55,760 --> 00:14:56,880
让我们打印出来。

288
00:14:56,960 --> 00:15:03,620
然后我们将调用 eval responsive ideal 函数

289
00:15:04,320 --> 00:15:07,720
看看响应与理想答案的匹配程度。

290
00:15:08,280 --> 00:15:11,920
在这种情况下，它输出了我们想要的类别

291
00:15:11,980 --> 00:15:15,220
并输出了整个产品列表。

292
00:15:15,280 --> 00:15:18,680
这给你得分为 1.0。

293
00:15:20,560 --> 00:15:22,420
再给你展示一个例子，

294
00:15:22,420 --> 00:15:26,920
结果我知道它在第七个例子上做错了。

295
00:15:27,400 --> 00:15:30,600
所以如果我把这个从零改成七并运行它，

296
00:15:34,560 --> 00:15:35,920
这就是它得到的结果。

297
00:15:36,000 --> 00:15:41,100
哦，让我也把这个更新为七。

298
00:15:41,160 --> 00:15:45,620
所以在这个客户信息下，这是理想的答案

299
00:15:45,700 --> 00:15:49,420
它应该在游戏机和配件下输出。
 
300
00:15:49,500 --> 00:15:51,420
这是游戏机和配件。

301
00:15:51,420 --> 00:15:54,620
但是这里的响应有三个输出，

302
00:15:55,420 --> 00:16:00,480
实际上应该有一个、两个、三个、四个、五个输出。

303
00:16:00,540 --> 00:16:02,740
所以它缺少了一些产品。

304
00:16:03,340 --> 00:16:07,740
所以如果我现在调整提示，我会使用一个for循环来循环遍历所有10个开发集示例

305
00:16:09,180 --> 00:16:15,020
在这里我们反复提取客户信息，

306
00:16:15,420 --> 00:16:18,140
获取理想答案，正确答案，

307
00:16:18,140 --> 00:16:21,500
调用arm获取响应，进行评估，

308
00:16:21,560 --> 00:16:24,700
然后，你知道的，累积平均值。

309
00:16:24,760 --> 00:16:26,800
让我来运行一下。

310
00:16:26,860 --> 00:16:28,100
好的。

311
00:16:28,160 --> 00:16:30,900
所以这将需要一段时间来运行，

312
00:16:30,960 --> 00:16:32,600
但是当它运行完毕时，这就是结果。

313
00:16:32,660 --> 00:16:34,860
我们正在运行这10个示例。

314
00:16:34,940 --> 00:16:37,740
看起来第七个示例是错误的。

315
00:16:37,800 --> 00:16:40,200
所以10个示例中正确的比例为90%。

316
00:16:43,660 --> 00:16:46,920
所以如果你需要调整提示，

317
00:16:46,980 --> 00:16:51,220
你可以重新运行这个程序，看看正确的百分比是上升还是下降。

318
00:16:51,780 --> 00:16:54,520
你刚刚在这个笔记本中看到了这个公告列表的第一、二、三步。

319
00:16:54,580 --> 00:16:58,720
这已经给出了一个相当不错的10个示例的开发集，

320
00:16:58,780 --> 00:17:03,120
用于调整和验证提示是否有效。

321
00:17:03,180 --> 00:17:06,420
如果你需要更高的严谨性，

322
00:17:07,120 --> 00:17:09,720
那么你现在拥有了所需的软件。
 
325
00:17:11,820 --> 00:17:15,800
收集大约100个随机样本

326
00:17:15,860 --> 00:17:17,800
以及它们的理想输出，

327
00:17:17,860 --> 00:17:20,800
甚至可以超越一个保留测试集的严谨性

328
00:17:20,860 --> 00:17:23,600
在你调整提示时，你甚至不看它。

329
00:17:23,660 --> 00:17:27,400
但对于许多应用程序，停留在第三个要点，

330
00:17:27,460 --> 00:17:29,400
但也肯定有应用程序

331
00:17:29,460 --> 00:17:33,100
你可以像在这个Jupyter笔记本中看到的那样做，

332
00:17:33,160 --> 00:17:36,560
并且很快就可以得到一个相当好的性能系统。

333
00:17:37,420 --> 00:17:39,600
再次强调，重要的是，

334
00:17:39,600 --> 00:17:43,400
如果你正在处理一个安全关键应用程序

335
00:17:43,460 --> 00:17:47,800
或者一个存在非微不足道风险的应用程序，

336
00:17:47,860 --> 00:17:50,600
那么当然，负责任的做法是

337
00:17:50,660 --> 00:17:52,300
在使用它之前获得一个更大的测试集

338
00:17:52,360 --> 00:17:55,540
以确实验证性能。

339
00:17:55,600 --> 00:17:56,800
就是这样。

340
00:17:56,860 --> 00:18:00,300
我发现使用提示构建应用程序的工作流程

341
00:18:00,360 --> 00:18:04,000
与使用监督学习构建应用程序的工作流程非常不同。

342
00:18:04,060 --> 00:18:05,800
因此，我认为这是需要记住的一件好事

343
00:18:05,860 --> 00:18:08,400
当你正在构建监督学习时。

344
00:18:08,400 --> 00:18:10,340
迭代的速度感觉要快得多。

345
00:18:10,400 --> 00:18:13,380
如果你还没有这样做过，

346
00:18:13,440 --> 00:18:15,700
你可能会惊讶于一个评估方法

347
00:18:15,780 --> 00:18:19,900
仅建立在一些手工策划的棘手例子上的表现如何。
 
349
00:18:23,040 --> 00:18:24,700
你可能认为只有10个例子是不具有统计学意义的。

350
00:18:24,780 --> 00:18:28,180
但当你实际使用这个过程时，你可能会惊讶于添加一些棘手的例子到开发集中的有效性。

351
00:18:28,240 --> 00:18:30,840
但你可能会惊讶于当你实际使用这个过程时，

352
00:18:30,900 --> 00:18:33,580
添加一些棘手的例子到开发集中的有效性。

353
00:18:33,640 --> 00:18:36,880
这对于帮助你和你的团队找到有效的提示和有效的系统非常有帮助。

354
00:18:36,880 --> 00:18:38,620
在这个视频中，输出可以定量评估，

355
00:18:38,680 --> 00:18:41,640
就像有一个期望的输出一样，你可以判断它是否给出了这个期望的输出。

356
00:18:43,440 --> 00:18:49,120
因此，在下一个视频中，让我们看看如何在这种更加模糊的情况下评估我们的输出。

357
00:18:49,180 --> 00:18:51,680
在那种情况下，什么是正确答案是有点模糊的。

358
00:18:51,740 --> 00:18:55,340
接下来，让我们看看如何在这种更加模糊的情况下评估我们的输出。

359
00:18:55,420 --> 00:18:58,840
在下一个视频中，让我们看看如何评估我们的输出，

360
00:18:58,920 --> 00:19:02,540
在这种情况下，什么是正确答案是有点模糊的。

361
00:19:02,540 --> 00:19:07,540
在下一个视频中，让我们看看如何在这种更加模糊的情况下评估我们的输出。