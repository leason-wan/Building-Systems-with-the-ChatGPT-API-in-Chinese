1
00:00:00,000 --> 00:00:10,080
在本节中，我们将专注于处理输入的任务，即通过一系列步骤生成有用输出的任务。

2
00:00:10,080 --> 00:00:13,880
有时，模型在回答特定问题之前需要详细推理问题，如果您参加了我们之前的课程ChartGBT Prompt Engineering for Developers，

3
00:00:13,880 --> 00:00:17,980
您将看到许多这样的例子。

4
00:00:17,980 --> 00:00:23,160
有时，模型可能会通过匆忙得出错误的结论而出现推理错误，因此

5
00:00:23,160 --> 00:00:26,040
我们可以重新构思查询，要求模型在提供最终答案之前提供一系列相关的推理步骤，

6
00:00:26,040 --> 00:00:30,280
以便它可以更长时间、更有方法地思考问题。

7
00:00:30,280 --> 00:00:35,160
通常，我们称这种要求模型逐步推理问题的策略为思维链推理。

8
00:00:35,160 --> 00:00:40,640
对于某些应用程序，模型用于得出最终答案的推理过程可能不适合与用户共享。

9
00:00:40,640 --> 00:00:45,280
例如，在辅导应用程序中，我们可能希望鼓励学生自己解决问题，但模型对学生解决方案的推理过程可能会揭示答案。

10
00:00:45,280 --> 00:00:46,880
内心独白是一种可以用来缓解这种情况的策略，这只是一种隐藏模型推理过程的高级方法。

11
00:00:46,880 --> 00:00:51,600
内心独白的想法是指示模型将输出的部分放在

12
00:00:51,600 --> 00:00:54,000
不会透露答案的方式中，以便用户无法看到完整的推理过程。
 
19
00:01:17,280 --> 00:01:21,280
旨在将它们隐藏在一个结构化的格式中，使得传递它们变得容易。

20
00:01:21,280 --> 00:01:22,280
简单。

21
00:01:22,280 --> 00:01:26,360
然后，在向用户呈现输出之前，输出被传递，只有部分输出是可见的。

22
00:01:26,360 --> 00:01:29,080
输出被传递，只有部分输出是可见的。

23
00:01:29,080 --> 00:01:32,880
所以记住前面视频中的分类问题，我们要求模型将客户查询分类为主要和次要类别。

24
00:01:32,880 --> 00:01:37,840
根据这个分类，我们可能想采取不同的指令。

25
00:01:37,840 --> 00:01:42,040
基于这个分类，我们可能想采取不同的指令。

26
00:01:42,040 --> 00:01:46,860
想象一下客户查询已经被分类为产品信息类别。

27
00:01:46,860 --> 00:01:51,600
在下一个指令中，我们将想要包含有关我们可用产品的信息。

28
00:01:51,600 --> 00:01:57,640
因此，在这种情况下，分类将是主要的，一般的查询，次要的，产品信息。

29
00:01:57,640 --> 00:01:58,640
产品信息。

30
00:01:58,640 --> 00:02:02,360
因此，让我们从那里开始一个例子。

31
00:02:02,360 --> 00:02:08,760
因此，让我们从那里开始一个例子。

32
00:02:08,760 --> 00:02:15,800
因此，对于这个内心独白的例子，我们将从我们一直在使用的相同分隔符开始。

33
00:02:15,800 --> 00:02:16,800
相同分隔符。

34
00:02:16,800 --> 00:02:22,960
现在让我们通过我们的系统消息。

35
00:02:22,960 --> 00:02:27,680
因此，我们在这里要求模型在得出结论之前推理答案。

36
00:02:27,680 --> 00:02:30,400
因此，我们在这里要求模型在得出结论之前推理答案。

37
00:02:30,400 --> 00:02:34,540
因此，指令是，按照这些步骤回答客户查询。

38
00:02:34,540 --> 00:02:39,280
客户查询将用四个井号分隔，我们的分隔符。

39
00:02:39,280 --> 00:02:42,080
因此，我们已将其分成步骤。
 
40
00:02:42,080 --> 00:02:46,880
首先要决定用户是否在询问关于特定产品或产品的问题。

41
00:02:46,880 --> 00:02:47,880
产品类别不算。

42
00:02:47,880 --> 00:02:50,920
第二步，如果用户询问特定产品，请确定这些产品是否在以下列表中。

43
00:02:50,920 --> 00:02:55,920
第三步，如果消息包含上述列表中的产品，请列出用户在消息中做出的任何假设。

44
00:02:55,920 --> 00:02:57,480
例如，笔记本电脑X比笔记本电脑Y大，或者笔记本电脑Z有两年的保修期。

45
00:02:57,480 --> 00:03:00,440
现在我们已经包含了一份可用产品的列表。

46
00:03:00,440 --> 00:03:02,680
这里有五种可用的产品。

47
00:03:02,680 --> 00:03:05,800
它们都是笔记本电脑的不同品种。

48
00:03:05,800 --> 00:03:09,560
这些都是虚构的产品。

49
00:03:09,560 --> 00:03:14,000
它们实际上是由GPT-4生成的。

50
00:03:14,000 --> 00:03:20,480
第四步，如果用户做出了任何假设，请根据您的产品信息确定假设是否正确。

51
00:03:20,480 --> 00:03:22,480
第五步是，如果适用，先礼貌地纠正客户的错误假设。

52
00:03:22,480 --> 00:03:29,720
只提及或引用五种可用产品中的产品，因为这是商店售卖的唯一五种产品。

53
00:03:29,720 --> 00:03:33,360
并以友好的口吻回答客户。

54
00:03:33,360 --> 00:03:37,840
这些非常迂腐的指示对于更高级的语言模型（如GPT-4）可能是不必要的。 

注：原文中的GPT-4是笔误，应为GPT-3。
 
62
00:04:01,840 --> 00:04:05,440
然后我们将要求模型使用以下格式。

63
00:04:05,440 --> 00:04:08,920
所以第一步，分隔符，是推理。

64
00:04:08,920 --> 00:04:12,080
第二步，分隔符，推理，以此类推。

65
00:04:12,080 --> 00:04:16,600
使用分隔符意味着以后我们更容易获取客户的回复并切掉之前的所有内容。

66
00:04:16,600 --> 00:04:23,120
现在让我们来试一个例子用户消息。

68
00:04:27,240 --> 00:04:33,560
所以我们的消息是，蓝波Chromebook比TechPro台式机贵多少？

70
00:04:34,880 --> 00:04:39,280
让我们来看看这两个产品。

71
00:04:39,280 --> 00:04:48,440
蓝波Chromebook售价249.99美元，而TechPro台式机实际上售价999.99美元。

72
00:04:48,440 --> 00:04:50,560
这实际上是不正确的。

73
00:04:50,560 --> 00:04:56,680
那么让我们看看模型如何处理这个用户请求。

74
00:04:56,680 --> 00:05:03,880
所以我们将其格式化为我们的消息数组，并获取我们的回复。

75
00:05:03,880 --> 00:05:16,280
然后我们将打印它。

76
00:05:16,280 --> 00:05:20,400
所以我们希望模型能够采取所有这些不同的步骤，并意识到用户已经做出了不正确的假设，然后遵循最后一步礼貌地纠正用户。

79
00:05:29,840 --> 00:05:35,480
因此，在这个提示中，我们实际上维护了许多不同的复杂状态，系统在任何给定时刻可能会有不同的输出，我们希望做出不同的反应。

83
00:05:42,960 --> 00:05:49,040
例如，如果用户在第三步没有做出任何假设，那么在第四步中，我们将不会做出任何不同的反应。
 
84
00:05:49,040 --> 00:05:50,280
实际上没有任何输出。

85
00:05:50,280 --> 00:05:53,360
所以这是一个相当复杂的指令，针对模型。

86
00:05:53,360 --> 00:05:55,600
所以让我们看看它是否做对了。

87
00:05:55,600 --> 00:05:59,880
第一步，用户正在询问有关特定产品的问题。

88
00:05:59,880 --> 00:06:03,280
他们正在询问这两个产品之间的价格差异。

89
00:06:03,280 --> 00:06:08,520
用户认为BlueWave Chromebook比TechBook Pro更贵，但这种假设实际上是不正确的。

90
00:06:08,520 --> 00:06:10,960
它正在推理，花费更长的时间来思考问题。

91
00:06:10,960 --> 00:06:14,280
就像人类也需要一些时间来推理任何给定问题的答案一样，如果模型也有时间来思考，它的表现会更好。

92
00:06:14,280 --> 00:06:19,000
同样地，让我们看看另一个用户消息的例子。

93
00:06:19,000 --> 00:06:23,720
在这一点上，如果你想的话，可以暂停视频并尝试自己的消息。

94
00:06:23,720 --> 00:06:28,600
因此，对用户的最终回应是BlueWave Chromebook实际上比TechBook Pro便宜。

95
00:06:28,600 --> 00:06:29,880
TechBook Pro桌面电脑售价999.99美元，而BlueWave Chromebook售价249.99美元。

96
00:06:29,880 --> 00:06:38,640
让我们看看另一个用户消息的例子。

97
00:06:38,640 --> 00:06:42,840
在这一点上，如果你想的话，可以暂停视频并尝试自己的消息。

98
00:06:42,840 --> 00:06:49,600
所以让我们格式化这个用户消息。

99
00:06:49,600 --> 00:06:51,440
问题是，你们卖电视吗？

100
00:06:51,440 --> 00:06:53,760
如果你记得我们的产品列表，我们只列出了不同的计算机。

101
00:06:53,760 --> 00:06:58,360
所以让我们看看模型的回答。

102
00:06:58,360 --> 00:07:02,280
在这种情况下，第一步，用户正在询问商店是否销售电视，但电视并未列在可用产品中。
 
105
00:07:08,760 --> 00:07:13,200
所以，正如您所看到的，模型会跳过中间步骤，因为它意识到这些步骤实际上是不必要的。

106
00:07:13,200 --> 00:07:17,840
我要说的是，我们确实要求以这种特定的格式输出，因此从技术上讲，模型并没有完全遵循我们的要求。

107
00:07:17,840 --> 00:07:21,920
再次说明，更高级的模型将更擅长做到这一点。

108
00:07:21,920 --> 00:07:24,600
因此，在这种情况下，我们对用户的回应是，很抱歉，我们不在店里销售电视。

109
00:07:24,600 --> 00:07:27,960
然后它列出了可用的产品。

110
00:07:27,960 --> 00:07:32,240
因此，在这种情况下，我们只想要回应的这部分内容。

111
00:07:32,240 --> 00:07:33,240
我们不想向用户显示早期的部分。

112
00:07:33,240 --> 00:07:37,840
因此，我们可以在这个分隔符标记或四个井号的字符串的最后一次出现处截断字符串，然后只打印模型输出的最后部分。

113
00:07:37,840 --> 00:07:41,040
因此，随意尝试一些自己的回应。

114
00:07:41,040 --> 00:07:45,080
现在，我们只想要回应的这部分内容。

115
00:07:45,080 --> 00:07:47,920
我们不想向用户显示早期的部分。

116
00:07:47,920 --> 00:07:54,920
因此，我们实际上可以在这个分隔符标记或四个井号的字符串的最后一次出现处截断字符串，然后只打印模型输出的最后部分。

117
00:07:54,920 --> 00:08:03,600
因此，让我们编写一些代码，只获取此字符串的最后一部分。

118
00:08:03,600 --> 00:08:07,920
因此，我们将使用try except块来优雅地处理错误，以防模型具有某种不可预测的输出并且实际上不使用这些字符。

119
00:08:07,920 --> 00:08:13,200
因此，我们将说我们的最终回应是回应。

120
00:08:13,200 --> 00:08:19,120
然后，我们将在分隔符字符串处拆分字符串。

121
00:08:19,120 --> 00:08:23,600
因为我们想要最后一次出现，所以我们只想获取输出列表中的最后一项。

122
00:08:23,600 --> 00:08:26,560

 
125
00:08:32,920 --> 00:08:36,240
然后我们将去除任何空格。

126
00:08:36,240 --> 00:08:40,600
因为你可以看到，字符后面可能会有空格。

127
00:08:40,600 --> 00:08:55,080
我们将捕获任何错误并提供备用响应，即“抱歉，我现在有些困难。”

128
00:08:55,080 --> 00:09:01,960
请尝试提出另一个问题。

129
00:09:01,960 --> 00:09:08,440
然后让我们打印出最终的响应。

130
00:09:08,440 --> 00:09:22,160
因此，正如您所看到的，我们只需截取字符串即可获得最终输出。

131
00:09:22,160 --> 00:09:26,680
因此，如果我们将其构建到应用程序中，这就是我们将向用户显示的内容。

132
00:09:26,680 --> 00:09:32,400
总的来说，我只想指出，这个提示可能对于这个任务来说有些复杂。

133
00:09:32,400 --> 00:09:37,640
您可能实际上不需要所有这些中间步骤。

134
00:09:37,640 --> 00:09:38,640
任务。

135
00:09:38,640 --> 00:09:41,520
您可能实际上不需要所有这些中间步骤。

136
00:09:41,520 --> 00:09:46,760
因此，为什么不尝试看看是否可以找到更简单的方法来完成相同的任务。

137
00:09:46,760 --> 00:09:50,040
在您自己的提示中。

138
00:09:50,040 --> 00:09:55,200
总的来说，找到提示复杂性的最佳权衡需要一些实验。

139
00:09:55,200 --> 00:09:59,240
因此，在决定使用一个提示之前，一定要尝试许多不同的提示。

140
00:09:59,240 --> 00:10:04,840
在下一个视频中，我们将学习另一种处理复杂任务的策略，即将这些复杂任务分解为一系列更简单的子任务，而不是尝试完成整个任务。

141
00:10:04,840 --> 00:10:09,360
任务。

142
00:10:09,360 --> 00:10:36,440
在一个提示中。