1
00:00:00,000 --> 00:00:10,400
在本视频中，我们将学习如何通过将复杂任务拆分为一系列简单的子任务来链接多个提示。

2
00:00:10,400 --> 00:00:15,040
你可能会想，为什么要将任务拆分为多个提示，而不是像我们在上一个视频中学习的那样使用思维链推理一次性完成呢？我们已经证明了语言模型非常擅长遵循复杂的指令，特别是像GBT-4这样的高级模型。那么让我用两个比喻来解释为什么我们要这样做，来比较思维链推理和链接多个提示。 

3
00:00:15,040 --> 00:00:19,300
将任务拆分为多个提示的第一个比喻是一次性烹饪复杂的餐点与分阶段烹饪的区别。使用一个长而复杂的指令可能就像一次性烹饪复杂的餐点，你必须同时管理多个成分、烹饪技巧和时间。这可能很具有挑战性，难以跟踪每个部分并确保每个组成部分都烹饪完美。另一方面，链接多个提示就像分阶段烹饪餐点，你专注于一个组成部分，确保每个部分都正确烹饪后再进行下一个。这种方法可以分解任务的复杂性，使其更易于管理，并减少错误的可能性。但是，对于非常简单的食谱，这种方法可能是不必要和过于复杂的。

4
00:00:19,300 --> 00:00:23,060
同样的事情的一个稍微更好的比喻是，一次性完成所有任务与分阶段完成任务的区别。
 
17
00:01:20,380 --> 00:01:25,800
在阅读一长串代码和一个简单的模块化程序之间。

18
00:01:25,800 --> 00:01:30,160
使意大利面条代码变得糟糕和难以调试的是歧义和逻辑不同部分之间的复杂依赖关系。

19
00:01:30,160 --> 00:01:34,840
同样也适用于提交给语言模型的复杂单步任务。当您拥有可以在任何给定点维护系统状态并根据当前状态采取不同操作的工作流程时，链接提示是一种强大的策略。

20
00:01:34,840 --> 00:01:39,840
因此，当前状态的示例将在您分类了传入的客户查询之后，状态将是分类。

21
00:01:39,840 --> 00:01:44,380
所以这是一个账户问题还是一个产品问题。然后根据状态，您可能会做一些不同的事情。

22
00:01:44,380 --> 00:01:48,360
每个子任务仅包含任务的一个状态所需的指令，这使得系统更易于管理，确保模型具有执行任务所需的所有信息，并减少了错误的可能性，正如我所提到的那样。

23
00:01:48,360 --> 00:01:54,580
这种方法还可以降低成本，因为更长的提示和更多的标记会导致更高的运行成本，并且在某些情况下可能不需要概述所有步骤。

24
00:01:54,580 --> 00:01:59,460
这种方法的另一个好处是，它也更容易测试哪些步骤可能更经常失败，或者在特定步骤中有一个人参与。

25
00:01:59,460 --> 00:02:04,600
因此，总结一下，因为这是一个长的解释，而不是描述整个复杂的工作流程。
 
33
00:02:38,000 --> 00:02:42,420
在一个提示中列出数十个要点或几个段落，就像在上一个视频中一样，

34
00:02:42,420 --> 00:02:46,860
最好是在外部跟踪状态，然后注入相关的指令

35
00:02:46,860 --> 00:02:52,500
在需要时。什么使问题复杂？我认为一般来说，如果有许多不同的指令，而且潜在地所有指令都可以适用于任何

36
00:02:52,500 --> 00:02:56,080
给定的情况，这些情况可能会使模型难以推理

37
00:02:56,080 --> 00:03:00,460
该做什么。随着您与这些模型的构建和交互越来越多，您将获得

38
00:03:00,460 --> 00:03:04,080
何时使用此策略而不是以前的直觉。还有一个额外的好处

39
00:03:04,080 --> 00:03:08,420
我还没有提到的是，它还允许模型在必要时使用外部工具。例如，它可能决定查找某些内容

40
00:03:08,420 --> 00:03:13,640
在产品目录中或调用API或搜索知识库，这是使用单个提示无法实现的。因此，让我们深入一个例子。所以我们

41
00:03:13,640 --> 00:03:18,740
将使用与上一个视频中相同的示例，其中我们想回答客户的问题

42
00:03:18,740 --> 00:03:23,540
关于特定产品，但这次我们将使用更多的产品，并将步骤分解为许多不同的提示。所以我们将使用我们一直在使用的相同的分隔符。让我们阅读我们的系统消息。你

43
00:03:23,540 --> 00:03:29,360
将提供客户服务查询。客户服务查询将被分隔
 
49
00:03:57,540 --> 00:04:02,860
使用四个井号字符，输出一个Python对象列表，其中每个对象具有以下格式。类别，这是这些预定义字段之一，或产品。并且

50
00:04:02,860 --> 00:04:11,140
这是必须在以下允许的产品中找到的产品列表。其中类别和产品必须在客户服务查询中找到。如果提到了一个产品，

51
00:04:11,140 --> 00:04:15,620
它必须与以下允许的产品列表中的正确类别相关联。如果没有

52
00:04:15,620 --> 00:04:20,740
找到产品或类别，则输出一个空列表。现在我们有了允许的

53
00:04:20,740 --> 00:04:24,860
产品列表。因此，我们有类别，然后是这些类别中的产品。

54
00:04:24,860 --> 00:04:29,540
现在最后的指令是仅输出对象列表，没有其他内容。所以接下来我们有

55
00:04:29,540 --> 00:04:36,060
我们的用户消息。因此，这条消息是，告诉我关于Smart X Pro手机和

56
00:04:36,060 --> 00:04:44,820
照片快照相机，DSLR相机。还告诉我关于你们的电视。所以我们询问两个

57
00:04:44,820 --> 00:04:50,220
特定产品以及这个电视类别。这两个产品都被提到在允许的产品列表中。然后我们还有一个电视节目。

58
00:04:50,220 --> 00:04:56,860
然后我们将系统消息和用户消息格式化为消息数组。然后

59
00:04:56,860 --> 00:05:04,980
我们从模型中获取完成情况。因此，正如您所看到的，对于我们的输出，我们有一个列表

60
00:05:04,980 --> 00:05:11,700
对象，每个对象都有类别和产品。因此，我们有Smart X Pro手机

61
00:05:11,700 --> 00:05:18,900
和照片快照DSLR相机。然后在最后一个对象中，我们实际上只有一个
 
65
00:05:44,180 --> 00:05:50,700
类别，因为我们没有提到任何特定的电视。因此，输出结构化响应的好处是我们可以将其读入Python列表中，这非常好。

66
00:05:50,700 --> 00:05:58,680
并且让我们尝试另一个例子。所以我们的第二个用户消息是，我的路由器不工作。

68
00:06:08,040 --> 00:06:14,480
如果您注意到列表中，我们实际上没有任何路由器。然后让我们正确地格式化这个并完成它。因此，正如您所看到的，在这种情况下，输出是一个空列表。

71
00:06:29,820 --> 00:06:33,700
如果我们找到任何产品和类别，我们希望将有关这些请求的产品和类别的一些信息加载到提示中，以便我们可以更好地回答客户问题。

73
00:06:38,460 --> 00:06:43,720
因此，在我们的工作流程中，此提示运行后的状态是产品已列出或未列出。在这种情况下，我们不会尝试查找任何内容，因为没有任何内容可查找。

76
00:06:52,980 --> 00:07:01,820
如果我真的将其构建成系统，我可能会使用类别名称，例如计算机和笔记本电脑之类的东西，以避免任何空格和特殊字符的奇怪情况。但是现在这应该可以工作。

79
00:07:11,140 --> 00:07:15,780
所以关于这个手机，这个相机和关于电视的一般信息。因此，我们需要有某种产品目录来查找这些信息。在这里，我们有我们的产品。
 
81
00:07:20,180 --> 00:07:28,860
我刚刚粘贴的信息。所以你可以看到，我们有大量的产品可供选择。所有这些产品都是假的，实际上是由GPT-4生成的。

82
00:07:28,860 --> 00:07:38,140
我们商店提供的所有产品都是假的，实际上是由GPT-4生成的。每个产品都有几个不同的字段，如名称、类别、品牌、保修等。因此，产品只是从产品名称到包含产品信息的对象的字典。请注意，每个产品都有一个类别。因此，我们想要查找用户询问的产品信息。因此，我们需要定义一些辅助函数，以允许我们按产品名称查找产品信息。因此，让我们创建一个函数，按名称获取产品，我们输入名称。然后，我们将返回产品字典，并获取名称为键的项的值，我们的回退只是无。因此，我们还想定义另一个辅助函数，以获取特定类别的所有产品。例如，当用户询问我们拥有的电视时，我们希望加载所有不同电视的所有信息。因此，按类别获取产品，输入类别名称字符串。为此，我们要循环遍历产品字典中的所有产品，并检查每个产品，以查看类别是否等于输入类别。如果是这样，我们要返回它。因此，我们将按以下方式执行此操作。首先，
 
97
00:09:09,420 --> 00:09:12,660
我们想要循环遍历每个产品并获取值，因为我们需要访问值中的类别。然后，如果产品类别等于我们的输入类别，我们将返回此产品。

98
00:09:12,660 --> 00:09:21,340
因此，让我们为每个这些辅助函数做一个示例。首先，我们有一个名为TechPro Ultrabook的产品。因此，让我们按名称获取产品信息。在这里，您可以看到我们刚刚获取了所有产品信息。让我们做一个示例，获取类别中的所有产品。

99
00:09:21,340 --> 00:09:40,100
因此，在这里，您可以看到我们获取了此类别的所有产品。让我们继续我们的示例。只是为了记住我们在哪里，让我们打印用户消息。因此，用户消息是，告诉我关于SmartX Pro手机、相机和电视的信息。然后，模型的初始输出是这样的。因此，我们还需要读取来自模型的此输出，它是一个字符串。我们需要将其传递到列表中，以便我们可以将其用作我们刚刚编写的辅助函数的输入。因此，这就是一个辅助函数来完成这项工作。因此，我们将使用Python JSON模块。我们将编写一个名为read string to list的函数，一个非常描述性的标题，输入字符串。因此，首先我们将检查输入字符串是否为none。以防万一之前的某个步骤失败了，我们
 
113
00:11:18,060 --> 00:11:26,300
现在我们将返回空值。然后我们将使用try except块来确保捕获任何错误。

114
00:11:26,300 --> 00:11:35,460
首先，我们将把输入字符串中的任何单引号替换为双引号，以确保我们可以传递JSON。然后我们将使用JSON loads函数将输入字符串读入数组或列表中。然后我们将返回这个列表。如果有解码错误，我们将打印错误并返回none。让我们用我们的示例来试试。所以我们将使用read string to list帮助函数获取我们的类别和产品列表，并将其应用于模型的响应。然后我们将打印这个列表。所以它应该看起来一样。让我先运行这个。正如你所看到的，它只是相同的东西，只是现在这个变量的类型实际上是一个列表，而不是一个字符串。所以我们所做的整个目的是将产品信息放入一个列表中，我们可以将其添加到下一条指令中，这将是我们要求它回答用户问题的指令。

125
00:12:36,780 --> 00:12:41,660
为了做到这一点，我们需要将产品信息放入一个漂亮的字符串格式中，以便我们可以将其添加到提示中。所以让我们也创建一个帮助函数来做这个。所以我们将它称为生成输出字符串。它将接受我们刚刚创建的数据列表。然后我将复制一些代码，然后我们将逐步进行。
 
129
00:12:59,060 --> 00:13:03,620
它在做什么。现在我要粘贴一些代码并给你展示一个例子。然后我们将讨论这个函数在做什么。所以我们将从我们的第一个用户消息中获取产品信息。因此，我们将使用这个辅助函数生成输出字符串，它基于我们的类别和产品列表，如果我们记得的话，就是这样的。所以这里我们有所有在用户消息中提到的产品的产品信息。所以我们有他们提到的手机，我们有他们提到的相机，然后我们有所有我们的电视的产品信息。这些信息将有助于模型回答用户的初始问题。如果你对这个函数的工作方式感兴趣，我会简要概述一下，但你可以随意暂停视频并更仔细地阅读它。所以它基本上只是循环遍历这个列表中的所有对象，首先检查是否有产品。如果有，它会获取每个产品的信息，然后检查是否有类别，如果没有任何产品，那就是对于这个对象，例如，然后它获取该类别中所有产品的产品信息，并将它们添加到这个字符串中。然后它返回这个字符串。所以在这一点上，我们已经找到了相关的产品信息来回答用户的问题。现在是时候让模型来回答用户的问题了。
 
145
00:14:30,820 --> 00:14:38,660
实际上回答这个问题。所以让我们有我们的系统消息。这是指令。

146
00:14:38,660 --> 00:14:42,420
对于大型电子商店的客户服务助手，以友好和有帮助的口吻回答，让我们说，非常简洁的答案。确保向用户提出相关的后续问题。

147
00:14:42,420 --> 00:14:48,340
所以我们希望这是用户的交互体验。因此，作为提醒，这是我们最初的用户消息。我会再次添加它。现在我们将有我们的消息数组。这是模型的输入。让我们

148
00:14:48,340 --> 00:14:52,900
浏览一下。我们有我们的第一条消息，通常是系统消息。我们有

149
00:14:52,900 --> 00:15:00,260
用户消息。然后我们有这个额外的助手消息。这是包含我们刚刚查找的所有产品信息的消息。所以我们说

150
00:15:00,260 --> 00:15:06,540
相关的产品信息，新行，然后是我们刚刚找到的产品信息。现在模型具有所需的相关上下文，以便能够回答这个

151
00:15:06,540 --> 00:15:12,460
用户的问题。所以让我们得到最终的响应并打印它。我们希望模型

152
00:15:12,460 --> 00:15:21,020
将使用产品信息中的相关信息以有帮助的方式回答用户。所以首先它告诉用户关于Smart X Pro手机，告诉

153
00:15:21,020 --> 00:15:25,980
用户关于PhotoSnap相机，然后谈论我们库存中的不同电视，然后问后续问题。所以您可以看到，通过打破这个
 
161
00:16:15,860 --> 00:16:21,060
通过一系列步骤，我们能够加载与用户查询相关的信息，

162
00:16:21,060 --> 00:16:25,060
为模型提供所需的相关上下文，以有效回答问题。

163
00:16:25,060 --> 00:16:29,400
你可能会想，为什么我们要有选择地将产品描述加载到提示中，

164
00:16:29,400 --> 00:16:33,660
而不是包含所有产品描述，让模型使用它所需的信息呢？

165
00:16:33,660 --> 00:16:38,740
我的意思是，为什么我们不只是在提示中包含所有这些产品信息，

166
00:16:38,740 --> 00:16:42,540
这样我们就不必费心去查找产品信息的所有中间步骤了？

167
00:16:42,540 --> 00:16:48,860
这其中有几个原因。首先，包含所有产品描述可能会使上下文对模型更加混乱，

168
00:16:48,860 --> 00:16:52,580
就像对于试图一次处理大量信息的人一样。我会说，对于像GPT-4这样更高级的模型来说，

169
00:16:52,580 --> 00:16:56,940
这个问题不太相关，特别是当上下文像这个例子一样结构良好时，

170
00:16:56,940 --> 00:17:02,660
模型足够聪明，只会忽略明显不相关的信息。接下来的原因更有说服力。

171
00:17:02,660 --> 00:17:06,700
第二个原因是，语言模型有上下文限制，即固定数量的标记允许作为输入和输出。

172
00:17:06,700 --> 00:17:12,420
因此，如果你有大量的产品，想象一下你有一个巨大的产品目录，

173
00:17:12,420 --> 00:17:16,820
你甚至无法将所有描述都放入上下文窗口中。

174
00:17:16,820 --> 00:17:22,140
最后一个原因是，包含所有产品描述可能会使模型过度拟合，

175
00:17:22,140 --> 00:17:26,100
因为它会记住所有的产品描述，而不是只记住与查询相关的信息。

176
00:17:26,100 --> 00:17:30,940
这可能会导致模型在处理新的查询时表现不佳。
 
177
00:17:30,940 --> 00:17:36,220
使用语言模型时，由于按标记付费，可能会很昂贵。因此，通过有选择地加载信息，可以减少生成响应的成本。一般来说，确定何时动态加载信息到模型的上下文中，并允许模型决定何时需要更多信息，是增强这些模型能力的最佳方法之一。并且要再次强调，您应该将语言模型视为需要必要上下文才能得出有用结论和执行有用任务的推理代理。因此，在这种情况下，我们必须向模型提供产品信息，然后它才能根据该产品信息进行推理，为用户创建有用的答案。在这个例子中，我们只添加了一个特定函数或函数的调用，以通过产品名称获取产品描述或通过类别名称获取类别产品。但是，模型实际上擅长决定何时使用各种不同的工具，并可以正确地使用它们。这就是chat GPT插件背后的思想。我们告诉模型它可以访问哪些工具以及它们的作用，它会在需要从特定来源获取信息或想要采取其他适当的操作时选择使用它们。在我们的例子中，我们只能通过精确的产品和类别名称匹配查找信息，但还有更高级的信息检索技术。检索信息的最有效方法之一是使用自然语言处理技术，例如命名实体识别和关系提取。
 
193
00:18:47,340 --> 00:18:51,700
使用文本嵌入来获取信息。嵌入可以用于实现对大型语料库的高效知识检索，以查找与给定查询相关的信息。

194
00:18:51,700 --> 00:18:56,900
使用文本嵌入的一个关键优势是它们可以实现模糊或语义搜索，这使您能够在不使用精确关键字的情况下找到相关信息。因此，在我们的例子中，我们不一定需要产品的确切名称，但我们可以使用更一般的查询，如“手机”进行搜索。我们计划很快创建一门全面的课程，介绍如何在各种应用中使用嵌入，敬请关注。

195
00:18:56,900 --> 00:19:02,180
接下来，让我们进入下一个视频，讨论如何评估语言模型的输出。我走了。